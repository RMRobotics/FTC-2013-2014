#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     HTSPB,          sensorI2CCustom)
#pragma config(Sensor, S4,     SMUX2,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftTread,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightTread,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     harvester,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     rightHang,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     leftHang,      tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    flagServo,            tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    wrist,                tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    elbow,                tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    stopper,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Copyright (c) 2014 Jon Xia, RM Robotics

//#define __BACKWARDSTART__
#include "../headers/drivers.h"
#include "../headers/smux_sensor_definitions.h"
#include "../headers/constants.h"
#include "../headers/RobotState.h"
#include "../headers/autonomousFunctions.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main() {
	RobotState state;
	initialize(&state);
	short leftSpeed, rightSpeed;
	short prevState = INITIALSTATE;
	bool distLess50;
	bool irDetected = false;
	bool sawRedBlue = false;
	bool sawRedBlue2 = false;
	float startAngle = 0;

	INITIALDRIVE();
	//waitForStart();
	wait1Msec(state.delayTime*1000);
	while(true){
		//if state changes: stop motors, play tone, reset timers, gyro and lights
		if (prevState != state.currentState){
			if (prevState != PARK_DRIVE2 && prevState != CHECKEND){
				stopMotors();
				leftSpeed = 0;
				rightSpeed = 0;
			}
			AUDIO_DEBUG(500, 15);
			time1[T1] = 0;
			resetGyroAccel(&state);
			LEDController(0x00);
			distLess50 = false;
			startAngle = state.degrees;
		}

		getSensors(&state);
		prevState = state.currentState;

		if(state.currentState == FINDLINE_TURN){
			drive(0, TURNSPEED);
			if(state.color2 == RED || state.color2 == BLUE){
				sawRedBlue = true;
			}
			if (sawRedBlue && state.color2 == BLACK){
				state.currentState = LINEFOLLOW;
			}
			if(abs(state.degrees) > 10){
				state.currentState = LINEFOLLOW;
			}
		/* state FINDLINE_DRIVE seems unnecessary
		} else if (state.currentState == FINDLINE_DRIVE) {
			drive(DRIVESPEED, DRIVESPEED*.95);
			if (state.irDir == 5 && irDetected == false) {
				state.currentState = SCOREBLOCK;
			} else if(state.color2 == RED || state.color2 == BLUE){
				state.currentState = LINEFOLLOW;
			} */
		} else if (state.currentState == LINEFOLLOW) {
			if (state.dist < 50) {
				distLess50 = true;
			}
			if (state.color == RED || state.color == BLUE) {
				sawRedBlue2 = true;
			}
			if (state.irDir == 5 && irDetected == false) {
				state.currentState = SCOREBLOCK;
			} else if (state.dist > 75 && distLess50 && sawRedBlue2) {
				state.currentState = PARK_TURN1;
			} else {
				if (state.color2 == RED || state.color2 == BLUE) {
					PlayTone(700, 10);
					leftSpeed = DRIVESPEED*LINEFOLLOWRATIO;
					rightSpeed = DRIVESPEED;
				} else {
					leftSpeed = DRIVESPEED;
					rightSpeed = DRIVESPEED*LINEFOLLOWRATIO;
				}
			}
			drive(leftSpeed, rightSpeed);
		} else if (state.currentState == SCOREBLOCK) {
			irDetected = true;
			LEDController(B2);
			blockScorer();
			state.currentState = LINEFOLLOW;
		} else if (state.currentState == PARK_TURN1) {
			drive(TURNSPEED, -TURNSPEED);
			if(abs(state.degrees) >= 12){
				state.currentState = PARK_DRIVE1;
			}
		} else if (state.currentState == PARK_DRIVE1) {
			drive(DRIVESPEED, DRIVESPEED);
			if((state.color2 == RED || state.color2 == BLUE) && time1[T1] >= 1000){
				state.currentState = PARK_TURN2;
			}
		} else if (state.currentState == PARK_TURN2) {
			DRIVESPECIAL(-TURNSPEED, TURNSPEED);
			if(abs(state.degrees) >= ANGLESPECIAL){
				state.currentState = PARK_DRIVE2; //Skip state HARVEST
			}
		} else if (state.currentState == HARVEST) {
			motor[harvester] = 100;
			if (time1[T1] < 750) {
				DRIVESPECIAL(2*DRIVESPEED, 2*DRIVESPEED);
			} else {
				leftSpeed = startAngle/abs(startAngle)*TURNSPEED;
				rightSpeed = -startAngle/abs(startAngle)*TURNSPEED;
				drive(leftSpeed, rightSpeed);
				if (abs(startAngle-state.degrees) <= 0.5){
					state.currentState = PARK_DRIVE2;
				}
			}
		} else if (state.currentState == PARK_DRIVE2) {
			DRIVESPECIAL(-2*DRIVESPEED, -2*DRIVESPEED);
			if(abs(state.x_accel) > 35 && state.x_accel < 45){
				wait1Msec(20);
				state.currentState = CHECKEND;
			}
		} else if (state.currentState == CHECKEND) {
			if(abs(state.x_accel) > 35 && abs(state.x_accel) < 45){
				state.currentState = END; //if it's still > 30 100ms after trigger
			} else {
				state.currentState = PARK_DRIVE2; //else you need to do more pushing
			}
		} else if (state.currentState == END){
			DRIVESPECIAL(-2*DRIVESPEED, -2*DRIVESPEED);
			if(time1[T1] >= 1000){
				break;
			}
		} else { //if error occured
			break;
		}
	}
}
