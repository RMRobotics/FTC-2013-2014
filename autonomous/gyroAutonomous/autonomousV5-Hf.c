#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     HTSPB,          sensorI2CCustom)
#pragma config(Sensor, S4,     SMUX2,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftTread,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightTread,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     harvester,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     rightHang,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     leftHang,      tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    flagServo,            tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    wrist,                tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    elbow,                tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    stopper,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Copyright (c) 2014 Jon Xia, RM Robotics

//#define __BACKWARDSTART__
#include "../../headers/drivers.h"
#include "../../headers/smux_sensor_definitions.h"
#include "../../headers/constants.h"
#include "../../headers/RobotState.h"
#include "../../headers/autonomousFunctions.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main() {
	RobotState state;
	initialize(&state);
	short leftSpeed, rightSpeed;
	short prevState = INITIALSTATE;
	bool distLess50;
	bool irDetected = false;
	bool goBackward = false;
	float startAngle = 0;
	int numTimeAccelTriggered = 0;

	waitForStart();
	wait1Msec(state.delayTime*1000);
	INITIALDRIVE();
	while(true){
		//if state changes: stop motors, play tone, reset timers, gyro and lights
		if (prevState != state.currentState){
			if (prevState != PARK_DRIVE2 && prevState != CHECKEND){
				stopMotors();
				leftSpeed = 0;
				rightSpeed = 0;
			}
			AUDIO_DEBUG(500, 10);
			time1[T1] = 0;
			resetGyroAccel(&state);
			LEDController(0x00);
			distLess50 = false;
			startAngle = state.degrees;
		}

		getSensors(&state);
		prevState = state.currentState;

		if(state.currentState == FINDLINE_TURN){
			drive(0, TURNSPEED);
			if(abs(state.degrees) > 10){
				state.currentState = LINEFOLLOW;
			}
		} else if (state.currentState == LINEFOLLOW) {
			if (state.dist < 50) {
				distLess50 = true;
			}
			if (state.irDir == 5 && irDetected == false) {
				state.currentState = SCOREBLOCK;
			} else if (state.dist > 50 && distLess50 && irDetected == true){
				state.currentState = GOTOEND;
			} else if (goBackward){
				leftSpeed = -DRIVESPEED;
				rightSpeed = -DRIVESPEED;
			} else {
				leftSpeed = DRIVESPEED;
				rightSpeed = DRIVESPEED;
			}
			drive(leftSpeed, rightSpeed);
		} else if (state.currentState == SCOREBLOCK) {
			irDetected = true;
			goBackward = true;
			LEDController(B2);
			blockScorer();
			state.currentState = LINEFOLLOW;
		} else if (state.currentState == GOTOEND) {
			drive(-DRIVESPEED, -DRIVESPEED);
			if(time1[T1] >= 300) {
				state.currentState = PARK_TURN1;
			}
		} else if (state.currentState == PARK_TURN1) {
			drive(-TURNSPEED, TURNSPEED);
			if(abs(state.degrees) >= 15){
				state.currentState = PARK_DRIVE1;
			}
		} else if (state.currentState == PARK_DRIVE1) {
			drive(-DRIVESPEED, -DRIVESPEED);
			if((state.color == RED || state.color == BLUE) && time1[T1] > 500){
				state.currentState = PARK_TURN2;
			}
		} else if (state.currentState == PARK_TURN2) {
			DRIVESPECIAL(-TURNSPEED, TURNSPEED);
			if(abs(state.degrees) >= 27){
				state.currentState = PARK_DRIVE2; //skip state HARVEST
			}
		} else if (state.currentState == HARVEST) {
			motor[harvester] = 100;
			DRIVESPECIAL(2*DRIVESPEED, 2*DRIVESPEED);
			if (time1[T1] >= 500){
				leftSpeed = startAngle/abs(startAngle)*TURNSPEED;
				rightSpeed = -startAngle/abs(startAngle)*TURNSPEED;
				drive(leftSpeed, rightSpeed);
				if (abs(startAngle-state.degrees) <= 0.5){
					state.currentState = PARK_DRIVE2;
				}
			}
		} else if (state.currentState == PARK_DRIVE2) {
			DRIVESPECIAL(-2*DRIVESPEED, -2*DRIVESPEED);
			if(abs(state.x_accel) > 35 && time1[T1] >= 300){
				numTimeAccelTriggered++;
			} else {
				numTimeAccelTriggered = 0;
			}
			if (numTimeAccelTriggered >= 3) {
				state.currentState = END;
			}
			wait1Msec(20);
		} else if (state.currentState == END){
			DRIVESPECIAL(-2*DRIVESPEED, -2*DRIVESPEED);
			if(time1[T1] >= 300){
				break;
			}
		} else {
			break;
		}
	}
}
