#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTGYRO,         sensorAnalogInactive)
#pragma config(Sensor, S3,     HTColor,        sensorI2CCustom)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     rightTread,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     leftTread,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     frontBottomLift, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backBottomLift, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     frontTopLift,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     backTopLift,   tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    vert1,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    vert2,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//nPowerDownDelayMinutes to not make robot asleep

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           RMRobotics Tele-Operation Mode Code
//
// Program for teleop (remote control) portion of 2012-2013 FTC game: Ring It Up
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define WRISTSPEED .3
#define LOPEG 23
#define MIDPEG 42
#define HIPEG 80

typedef struct {
	TJoystick joy;

	short joy1_Buttons_Changed;  // Bit map for the 12 buttons. 1 means that the button changed state
	short joy2_Buttons_Changed;
} UserInput;

typedef struct {
	// Keep track what buttons were previously pressed so that
	// we can figure out whether their state changed.
	short old_joy1_Buttons;
	short old_joy2_Buttons;

	// Keep track of left and right tread speeds
	int leftTreadSpeed;
	int rightTreadSpeed;

	// Keep track of wrist servos' positions
	float vert1Pos; // (0 - 247)
	float vert2Pos; // (0 - 227)

	// Keep track of lift speed
	int liftSpeed;

	int liftMode;

} State;

void getLatestInput(State *state, UserInput *input);
void handleDriveInputs(State *state, UserInput *input);
void handleLiftInputs(State *state, UserInput *input);
void handleSpecialInputs(State *state, UserInput *input);
void implementSpecialInputs(State *state);
void handleWristInputs(State *state, UserInput *input);
void verifyCommands(State *state);
void updateAllMotors(State *state);
void showDiagnostics(State *state);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  servo[vert1] = 234;
  servo[vert2] = 249;

  // Disable joystick driver's diagnostics display to free up nxt screen for our own diagnostics diplay
	disableDiagnosticsDisplay();

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// This is the main loop for the Tele-op program.
//
// The current controls to the robot are the following:
//
//               _==7==_                               _==8==_
//              / __5__ \                             / __6__ \
//            +.-'_____'-.---------------------------.-'_____'-.+
//           /   |     |  '.                       .'  |     |   \
//          / ___| /|\ |___ \                     / ___|(Y/4)|___ \
//         / |      |      | ;   __        __    ; |             | ;
//         | | <---   ---> | |  |__|      |__|   | |(X/1)   (B/3)| |
//         | |___   |   ___| ; BACK/9   START/10 ; |___       ___| ;
//         |\    | \|/ |    /  _     ___      _   \    |(A/2)|    /|
//         | \   |_____|  .','" "', |___|  ,'" "', '.  |_____|  .' |
//         |  '-.______.-' /       \ MODE /       \  '-._____.-'   |
//         |               |       |------|       |                |
//         |              /\       /      \       /\               |
//         |             /  '.___.'        '.___.'  \              |
//         |            /                            \             |
//          \          /                              \           /
//           \________/                                \_________/
//
// Controls
//   Controller 1
//     Left Joystick:................Left tread speed (analog control)
//     Right Joystick:...............Right tread speed (analog control)
//     X/1:..........................Dispensing wrist position and height
//     A/2:..........................Low peg wrist position and height
//     B/3:..........................Mid peg wrist position and height
//     Y/4:..........................High peg wrist position and height
//   Controller 2
//     X/1:..........................Starting wrist position
//     B/3:..........................Dispensing wrist position
//     Y/4:..........................Raise wrist
//     A/2:..........................Lower wrist
//     Right Bumper/6:.................Raise lift
//     Right Trigger/8:................Loswer lift
//     Tophat/D-pad
//       Up:.........................Raise wrist angle
//       Down:.......................Lower wrist angle
//
// NOTE: ASCII Art adapted from: http://chris.com/ascii/index.php?art=video%20games/other
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	// Initialize state values
  State currentState;
  memset(&currentState, 0, sizeof(currentState));
  currentState.vert1Pos = 254;
  currentState.vert2Pos = 249;

  waitForStart();   // wait for start of tele-op phase

  while (true)
  {
  	// Get latest user input
  	UserInput input;
  	getLatestInput(&currentState, &input);

  	// Process user inputs
  	handleDriveInputs(&currentState, &input);
  	handleLiftInputs(&currentState, &input);
  	//handleSpecialInputs(&currentState, &input);
  	handleWristInputs(&currentState, &input);

  	// Verify validity/possibility of commands
  	verifyCommands(&currentState);

  	// Execute user inputs
  	updateAllMotors(&currentState);
  	showDiagnostics(&currentState);
  }
}

void getLatestInput(State *state, UserInput *input)
{
	// Get the current joystick position
	getJoystickSettings(joystick);

	// Fill out our input structure
	memcpy(input->joy, joystick, sizeof(TJoystick));

	// Calculate which buttons changed.
	input->joy1_Buttons_Changed = input->joy.joy1_Buttons ^ state->old_joy1_Buttons;
	input->joy2_Buttons_Changed = input->joy.joy2_Buttons ^ state->old_joy2_Buttons;

	// Update state for next time.
	state->old_joy1_Buttons = input->joy.joy1_Buttons;
	state->old_joy2_Buttons = input->joy.joy2_Buttons;
}

int joyButton(short bitmask, int button)
{
	//return 1 or 0 based on whether button in bitmask is pressed or not
	return bitmask & (1 << (button - 1));
}

int getHeight() {
	return SensorValue[sonar] * (SensorValue[sonar] != 255);
}

void handleDriveInputs(State *state, UserInput *input)
{
	if (abs(input->joy.joy1_y2) > 20) { // If left joystick is outside dead zone, move left tread, otherwise stop.
		state->leftTreadSpeed = input->joy.joy1_y2 * (100.0 / 128.0) + 0.5;
	} else {
		state->leftTreadSpeed = 0;
	}

	if (abs(input->joy.joy1_y1) > 20) { // If right joystick is outside dead zone, move right tread, otherwise stop.
		state->rightTreadSpeed = input->joy.joy1_y1 * (100.0 / 128.0) + 0.5;
	} else {
		state->rightTreadSpeed = 0;
	}
}

void handleLiftInputs(State *state, UserInput *input)
{
	if (joyButton(input->joy.joy2_Buttons, 6)) {
		state->liftMode = 0;
		state->liftSpeed = 100;
	} else if (joyButton(input->joy.joy2_Buttons, 8)) {
		state->liftMode = 0;
		state->liftSpeed = -15;
	} else if (state->liftMode != 0) {
		// don't change lift state
	} else {
		state->liftSpeed = 0;
	}
}

void handleSpecialInputs(State *state, UserInput *input)
{
	if(joyButton(input->joy.joy1_Buttons, 1) && joyButton(input->joy1_Buttons_Changed, 1)){
		state->liftMode = LOPEG;
		state->vert1Pos = 123;
		state->vert2Pos = 118;
	} else if(joyButton(input->joy.joy1_Buttons, 2) && joyButton(input->joy1_Buttons_Changed, 2)){
		state->liftMode = LOPEG;
		state->vert1Pos = 86;
		state->vert2Pos = 81;
	} else if(joyButton(input->joy.joy1_Buttons, 3) && joyButton(input->joy1_Buttons_Changed, 3)){
		state->liftMode = MIDPEG;
		state->vert1Pos = 86;
		state->vert2Pos = 81;
	} else if(joyButton(input->joy.joy1_Buttons, 4) && joyButton(input->joy1_Buttons_Changed, 4)){
		state->liftMode = HIPEG;
		state->vert1Pos = 86;
		state->vert2Pos = 81;
	}

	if (state->liftMode != 0) {
		implementSpecialInputs(state);
	}
}

void implementSpecialInputs(State *state) {
		if ((getHeight() - state->liftMode) > 5) {
			state->liftSpeed = -15;
		} else if ((getHeight() - state->liftMode) < 5) {
			state->liftSpeed = 100;
	 	} else {
	 		state->liftSpeed = 0;
	 		state->liftMode = 0;
	 	}
}

void handleWristInputs(State *state, UserInput *input)
{
	// Controls for wrist servos
	// Controls for synchronized movement of vertical servos
	//   (keeps the angle of the hand relative to the ground constant)
	if (joyButton(input->joy.joy2_Buttons, 4)) {
		state->vert1Pos -= WRISTSPEED;
		state->vert2Pos -= WRISTSPEED;
	} else if (joyButton(input->joy.joy2_Buttons, 2)) {
		state->vert1Pos += WRISTSPEED;
		state->vert2Pos += WRISTSPEED;
	}

	// Controls for individual movement of 2nd vertical servo
	//   (allows the angle of the hand relative to the ground to be changed)
	if (input->joy.joy2_TopHat == 0) {
		state->vert2Pos += WRISTSPEED;
	} else if (input ->joy.joy2_TopHat == 4) {
		state->vert2Pos -= WRISTSPEED;
	}

	if (joyButton(input->joy.joy2_Buttons, 1)) {
		state->vert1Pos = 254;
		state->vert2Pos = 249;
	} else if (joyButton(input->joy.joy2_Buttons, 3)) {
		state->vert1Pos = 112;
		state->vert2Pos = 107;
	}
}

void verifyCommands(State *state)
{
	// If the projected servo values aren't within the servos' ranges,
	// stay at the servos' current positions.

	// Servo Ranges
	// vert1Pos (0-247)
  // vert2Pos (0-227)

	if (state->vert1Pos > 254 || state->vert2Pos < 0
	 || state->vert2Pos > 254 || state->vert2Pos < 0) {
		state->vert1Pos = ServoValue[vert1];
		state->vert2Pos = ServoValue[vert2];
	}
}

void updateAllMotors(State *state)
{
	motor[leftTread] = state->leftTreadSpeed;
	motor[rightTread] = state->rightTreadSpeed;
	motor[frontBottomLift] = state->liftSpeed;
	motor[backBottomLift] = state->liftSpeed;
	motor[frontTopLift] = state->liftSpeed;
	motor[backTopLift] = state->liftSpeed;
	servo[vert1] = state->vert1Pos;
	servo[vert2] = state->vert2Pos;
}

void showDiagnostics(State *state)
{
	//create label
	string sVert1Pos = "vert1 = ";
	string sVert2Pos = "vert2 = ";
	string height = "height =";
	string batteryLevel = "power = ";

	//store variable in a string
	string string1 = ServoValue[vert1]; //state->vert1Pos;
	string string2 = ServoValue[vert2]; //state->vert2Pos;
	string string3 = SensorValue[sonar];
	string string4 = externalBatteryAvg;

	//concat variable with label
	strcat(sVert1Pos, string1);
	strcat(sVert2Pos, string2);
	strcat(height, string3);
	strcat(batteryLevel, string4);

	eraseDisplay();

	//display label and value
	nxtDisplayTextLine(1, sVert1Pos);
	nxtDisplayTextLine(2, sVert2Pos);
	nxtDisplayTextLine(3, height);
	nxtDisplayTextLine(4, batteryLevel);
}
