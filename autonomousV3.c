#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S3,     HTSPB,          sensorI2CCustom)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rightTread,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightTread,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     leftTread,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftTread,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     flag,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     harvester,                 tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     leftHang,             tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     rightHang,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    auto1,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    auto2,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    stopper,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v1.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-accelerometer.h"
#include "drivers/hitechnic-superpro.h"

const tMUXSensor HTIRS = msensor_S4_1;
const tMUXSensor sonar = msensor_S4_2;
const tMUXSensor color = msensor_S4_3;
const tMUXSensor HTGYRO = msensor_S4_4;

#define FINDLINE 0
#define LINEFOLLOWER1 1
#define SCOREBLOCK 2
#define LINEFOLLOWER2 3
#define GOTOEND 4
#define PARKSEQUENCE1 5
#define PARKSEQUENCE2 6
#define PARKSEQUENCE3 7
#define PARKSEQUENCE4 8
#define END 9
#define FAIL 10

#define TURNSPEED 75
#define DRIVESPEED 50
#define LINEFOLLOWRATIO 0.5

typedef struct{
	int currentState;

	int leftSpeed;
	int rightSpeed;

	int irDir;
	int dist;
	int time;
	float degrees;
	//float x_distance;
	//float y_distance;
	//float z_distance;

	int lastSensorCheckTime;
} State;

void initialize(State *state);
void getSensors(State *state);
void resetGyroAccel(State * state);
void drive(State *state);
void stopMotors();
void showDiagnostics(State *state);

void initialize(State *state){
	memset(state, 0, sizeof(state));
	state->leftSpeed = DRIVESPEED;
	state->rightSpeed = DRIVESPEED;
	servo[auto1] = 100;
	servo[auto2] = 100;

	// Calibrate the gyro, make sure you hold the sensor still
	HTGYROstartCal(HTGYRO);
}

task main() {
	State state;
	initialize(&state);

	waitForStart();
	state.lastSensorCheckTime = time1[T2];

	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == FINDLINE){
		getSensors(&state);

		drive(&state);

		if(time1[T1] >= 3000){

			state.currentState = FAIL;

		}else if(state.irDir == 5){

			state.currentState = SCOREBLOCK;

		}else if(state.dist <= 50){

			stopMotors();
			state.currentState = LINEFOLLOWER1;

		}
	}


	bool special;
	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == LINEFOLLOWER1){
		getSensors(&state);

		drive(&state);

		if(state.irDir == 5){

			state.currentState = SCOREBLOCK;
			if (time1[T1] >= 3000)
				special = true;

		}else if(state.dist < 28){

			state.leftSpeed  = DRIVESPEED*LINEFOLLOWRATIO;
			state.rightSpeed = DRIVESPEED;

		}else if(state.dist > 32){

			state.leftSpeed = DRIVESPEED;
			state.rightSpeed = DRIVESPEED*LINEFOLLOWRATIO;

		}else if(time1[T1] >= 5000){

			state.currentState = LINEFOLLOWER2;

		}else { //in range between 45 and 55

			state.leftSpeed = DRIVESPEED;
			state.rightSpeed = DRIVESPEED;

		}
	}

	PlayTone(500,10);
	time1[T1] = 0;
	while(state.currentState == SCOREBLOCK){
		getSensors(&state);

		if(!special){
			wait1Msec(750);
		}
		stopMotors();
		servo[auto2] = 110;
		wait1Msec(100);
		servo[auto1] = 50;
		wait1Msec(400);
		servo[auto1] = 255;
		servo[auto2] = 0;

		//while(true){
		//	motor[leftTread] = 0;
		//	motor[rightTread] = 0;
		//	motor[leftHang] = 0;
		//	motor[rightHang] = 0;
		//	motor[harvester] = 0;
		//}

		state.currentState = LINEFOLLOWER2;
	}

	PlayTone(500,10);
	time1[T1] = 0;
	int numTimeGreater50 = 0;
	int numTimeLess50 = 0;
	while(state.currentState == LINEFOLLOWER2){
		getSensors(&state);

		//while(true){
		//	motor[leftTread] = 0;
		//	motor[rightTread] = 0;
		//	motor[leftHang] = 0;
		//	motor[rightHang] = 0;
		//	motor[harvester] = 0;
		//}
		drive(&state);

		/*if(state.irDir == 5){

			state.currentState = FAIL;

		}else*/ if(state.dist >= 50){

			numTimeGreater50++;
			numTimeLess50 = 0;
			if(numTimeGreater50 > 10 && numTimeLess50 > 10){
				state.currentState = GOTOEND;
			}

		} else if(state.dist > 32){

			state.leftSpeed  = DRIVESPEED;
			state.rightSpeed = DRIVESPEED*LINEFOLLOWRATIO;
			numTimeGreater50 = 0;
			numTimeLess50++;

		}else if(state.dist < 28){

			state.leftSpeed = DRIVESPEED*LINEFOLLOWRATIO;
			state.rightSpeed = DRIVESPEED;
			numTimeGreater50 = 0;
			numTimeLess50++;

		//}else if(time1[T1] >= 1500){

		//	state.currentState = GOTOEND;

		}else { //in range between 45 and 55

			state.leftSpeed = DRIVESPEED;
			state.rightSpeed = DRIVESPEED;
			numTimeGreater50 = 0;
			numTimeLess50++;

		}
	}

	PlayTone(500,10);
	time1[T1] = 0;
	while(state.currentState == GOTOEND){
		//getSensors(&state);
		//state.leftSpeed = DRIVESPEED;
		//state.rightSpeed = DRIVESPEED;
		//drive(&state);

		if(time1[T1] >= 0){
			state.currentState = PARKSEQUENCE1;
		}
	}

	state.currentState = PARKSEQUENCE1;
	PlayTone(500,1);
	time1[T1] = 0;
	resetGyroAccel(&state);
	while(state.currentState == PARKSEQUENCE1){
		getSensors(&state);
		state.leftSpeed = TURNSPEED;
		state.rightSpeed = -TURNSPEED;
		drive(&state);

		if(abs(state.degrees) >= 23){// || time1[T1] >= 500){
			stopMotors();
			state.currentState = PARKSEQUENCE2;
		}
	}

	PlayTone(500,10);
	time1[T1] = 0;
	while(state.currentState == PARKSEQUENCE2){
		getSensors(&state);
		state.leftSpeed = -DRIVESPEED;
		state.rightSpeed = -DRIVESPEED;
		drive(&state);

		if(time1[T1] >= 3000){
			state.currentState = PARKSEQUENCE3;
		}
	}

	PlayTone(500,10);
	time1[T1] = 0;
	resetGyroAccel(&state);
	while(state.currentState == PARKSEQUENCE3){
		getSensors(&state);
		state.leftSpeed = -TURNSPEED;
		state.rightSpeed = TURNSPEED;
		drive(&state);

		if(abs(state.degrees) >= 68){// || time1[T1] >= 500){
			stopMotors();
			state.currentState = PARKSEQUENCE4;
		}
	}

	PlayTone(500,10);
	time1[T1] = 0;
	while(state.currentState == PARKSEQUENCE4){
		getSensors(&state);
		state.leftSpeed = -DRIVESPEED;
		state.rightSpeed = -DRIVESPEED;
		drive(&state);

		if(time1[T1] >= 3000){
			stopMotors();
			state.currentState = END;
		}
	}

	PlayTone(500,10);
	while(state.currentState == END){

	}

	PlayTone(500,1);
	while(state.currentState == FAIL){
		stopMotors();
		state.currentState = END;
	}
}

void getSensors(State *state){

	//************************IR Sensor**************************

	int _dir = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;

	// read all of the sensors' values at once,
	// exit the app if an error occurs
	if (! HTIRSreadAllStrength(HTIRS, dcS1, dcS2, dcS3, dcS4, dcS5)) {
		nxtDisplayTextLine(4, "ERROR!!");
		wait1Msec(2000);
		StopAllTasks();
	}

	// read the direction from which the signal is coming,
	// exit the app if an error occurs
	_dir = HTIRSreadDir(HTIRS);
	if (_dir < 0) {
		nxtDisplayTextLine(4, "ERROR!!");
		wait1Msec(2000);
		StopAllTasks();
	}

	// display the info from the sensor
	/*nxtDisplayTextLine(0,"HT IR Seeker");
	nxtDisplayTextLine(2, "dir: %2d", _dir);
	nxtDisplayTextLine(3, "S1: %3d", dcS1);
	nxtDisplayTextLine(4, "S2: %3d", dcS2);
	nxtDisplayTextLine(5, "S3: %3d", dcS3);
	nxtDisplayTextLine(6, "S4: %3d", dcS4);
	nxtDisplayTextLine(7, "S5: %3d", dcS5);*/

	state->irDir = _dir;

	//*********************************************************

	//***********************Sonar*****************************

	state->dist = SensorValue[sonar];

	//*********************************************************

	//*****************Gyro and Accelerometer******************

	float rotSpeed = 0;
	//float x_axis, y_axis, z_axis = 0;

	//Wait until 20ms has passed
	wait1Msec(20);
	/*state->lastSensorCheckTime += 20;
	int waitTime = state->lastSensorCheckTime-time1[T2];
	if (waitTime >= 0 && waitTime <= 20) {
		wait1Msec(waitTime);
	} else {
		PlayTone(700, 1000);
		eraseDisplay();
		string errorDisplay;
		sprintf(errorDisplay, "missed %d",(int)(time1[T2] - state->lastSensorCheckTime));
		nxtDisplayTextLine(3, errorDisplay);
		stopMotors();
		wait1Msec(100000000000);
		state->lastSensorCheckTime = time1[T2];
	}*/


	// Read the current rotation speed
	rotSpeed = HTGYROreadRot(HTGYRO);
	//HTACreadAllAxes(HTACCEL, x_axis, y_axis, z_axis);

	// Crude integration: waited 20ms so distance moved/degrees turned would be speed * time
	state->degrees += rotSpeed * 0.02;
	//state->x_distance = x_axis * 0.02;
	//state->y_distance = y_axis * 0.02;
	//state->z_distance = z_axis * 0.02;

	//*********************************************************

	//*****************Show Debugging Window*******************

	showDiagnostics(state);

	//*********************************************************
}

void resetGyroAccel(State *state){
	state->degrees = 0;
	//state->x_distance = 0;
	//state->y_distance = 0;
	//state->z_distance = 0;
}

void drive(State *state){
	motor[leftTread] = state->leftSpeed;
	motor[rightTread] = state->rightSpeed;
}

void stopMotors(){
	motor[leftTread] = 0;
	motor[rightTread] = 0;
}

void showDiagnostics(State *state){
	//create label
	string displayState = "state = ";
	string sonarSensor = "sonar = ";
	string irSensor = "IR = ";
	string gyroSensor = "Gyro =";
	string timer = "Timer = ";
	string batteryLevel = "power = ";

	//store variable in a string
	string string0 = state->currentState;
	string string1 = state->dist; //ServoValue[vert1];
	string string2 = state->irDir; //ServoValue[vert2];
	string string3 = state->degrees;
	string string4 = time1[T1];
	string string5 = externalBatteryAvg;

	//concat variable with label
	strcat(displayState, string0);
	strcat(sonarSensor, string1);
	strcat(irSensor, string2);
	strcat(gyroSensor, string3);
	strcat(timer, string4);
	strcat(batteryLevel, string5);

	eraseDisplay();

	//display label and value
	nxtDisplayTextLine(1, displayState);
	nxtDisplayTextLine(2, sonarSensor);
	nxtDisplayTextLine(3, irSensor);
	nxtDisplayTextLine(4, gyroSensor);
	nxtDisplayTextLine(5, timer);
	nxtDisplayTextLine(6, batteryLevel);
}
