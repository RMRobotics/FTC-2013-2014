#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     HTIRS,          sensorI2CCustom)
#pragma config(Sensor, S3,     HTGYRO,         sensorI2CCustom)
#pragma config(Sensor, S4,     SMUX,           sensorI2CCustom)
#pragma config(Motor,  motorB,          rightTread,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftTread,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     leftTread,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightTread,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     harvester,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v1.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-accelerometer.h"

const tMUXSensor HTACCEL = msensor_S4_1;
const tMUXSensor sonar = msensor_S4_2;
const tMUXSensor color = msensor_S4_3;

#define FINDLINE 0
#define LINEFOLLOWER1 1
#define SCOREBLOCK 2
#define LINEFOLLOWER2 3
#define GOTOEND 4
#define PARKSEQUENCE1 5
#define PARKSEQUENCE2 6
#define PARKSEQUENCE3 7
#define PARKSEQUENCE4 8
#define END 9
#define FAIL 10

#define TURNSPEED 75
#define DRIVESPEED 50
#define LINEFOLLOWRATIO 0.50

typedef struct{
	int currentState;

	int leftSpeed;
	int rightSpeed;

	int irDir;
	int dist;
	int time;
	float degrees;
	float x_distance;
	float y_distance;
	float z_distance;

	int lastSensorCheckTime;
} State;

void initialize(State *state);
void getSensors(State *state);
void resetGyroAccel(State * state);
void drive(State *state);
void stopMotors();
void showDiagnostics(State *state);

void initialize(State *state){
	memset(state, 0, sizeof(state));
	state->leftSpeed = DRIVESPEED;
	state->rightSpeed = DRIVESPEED;

	// Calibrate the gyro, make sure you hold the sensor still
	HTGYROstartCal(HTGYRO);
}

task main() {
	State state;
	initialize(&state);

	//waitForStart();
	state.lastSensorCheckTime = time1[T2];

	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == FINDLINE){
		getSensors(&state);

		drive(&state);

		if(state.irDir == 5 || time1[T1] >= 3000){

			state.currentState = FAIL;

		}else if(state.dist <= 250){

			state.currentState = LINEFOLLOWER1;

		}
	}


	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == LINEFOLLOWER1){
		getSensors(&state);

		drive(&state);

		if(state.irDir == 5){

			state.currentState = SCOREBLOCK;

		}else if(state.dist <= 45){

			state.leftSpeed  = DRIVESPEED*LINEFOLLOWRATIO;
			state.rightSpeed = DRIVESPEED;

		}else if(state.dist >= 55){

			state.leftSpeed = DRIVESPEED;
			state.rightSpeed = DRIVESPEED*LINEFOLLOWRATIO;

		}else if(time1[T1] >= 3000){

			state.currentState = LINEFOLLOWER2;

		}else { //in range between 45 and 55

			state.leftSpeed = DRIVESPEED;
			state.rightSpeed = DRIVESPEED;

		}
	}

	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == SCOREBLOCK){
		getSensors(&state);

		stopMotors();
		//call Score Block Function

		if(time1[T1] >= 3000){

			state.currentState = LINEFOLLOWER2;

		}
	}

	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == LINEFOLLOWER2){
		getSensors(&state);

		drive(&state);

		/*if(state.irDir == 5){

			state.currentState = FAIL;

		}else*/ if(state.dist <= 45){

			state.leftSpeed  = DRIVESPEED*LINEFOLLOWRATIO;
			state.rightSpeed = DRIVESPEED;

		}else if(state.dist >= 250){

			state.currentState = GOTOEND;

		}else if(state.dist >= 55){

			state.leftSpeed = DRIVESPEED;
			state.rightSpeed = DRIVESPEED*LINEFOLLOWRATIO;

		}else if(time1[T1] >= 3000){

			state.currentState = GOTOEND;

		}else { //in range between 45 and 55

			state.leftSpeed = DRIVESPEED;
			state.rightSpeed = DRIVESPEED;

		}
	}

	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == GOTOEND){
		getSensors(&state);
		state.leftSpeed = DRIVESPEED;
		state.rightSpeed = DRIVESPEED;
		drive(&state);

		if(time1[T1] >= 2000){
			state.currentState = PARKSEQUENCE1;
		}
	}

	state.currentState = PARKSEQUENCE1;
	PlayTone(500, 10);
	time1[T1] = 0;
	resetGyroAccel(&state);
	while(state.currentState == PARKSEQUENCE1){
		getSensors(&state);
		state.leftSpeed = TURNSPEED;
		state.rightSpeed = -TURNSPEED;
		drive(&state);

		if(abs(state.degrees) >= 180.0){// || time1[T1] >= 500){
			stopMotors();
			state.currentState = PARKSEQUENCE2;
		}
	}

	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == PARKSEQUENCE2){
		getSensors(&state);
		state.leftSpeed = DRIVESPEED;
		state.rightSpeed = DRIVESPEED;
		drive(&state);

		if(time1[T1] >= 2000){
			state.currentState = PARKSEQUENCE3;
		}
	}

	PlayTone(500, 10);
	time1[T1] = 0;
	resetGyroAccel(&state);
	while(state.currentState == PARKSEQUENCE3){
		getSensors(&state);
		state.leftSpeed = TURNSPEED;
		state.rightSpeed = -TURNSPEED;
		drive(&state);

		if(abs(state.degrees) >= 90){// || time1[T1] >= 500){
			stopMotors();
			state.currentState = PARKSEQUENCE4;
		}
	}

	PlayTone(500, 10);
	time1[T1] = 0;
	while(state.currentState == PARKSEQUENCE4){
		getSensors(&state);
		state.leftSpeed = DRIVESPEED;
		state.rightSpeed = DRIVESPEED;
		drive(&state);

		if(time1[T1] >= 2000){
			stopMotors();
			state.currentState = END;
		}
	}

	PlayTone(500, 10);
	while(state.currentState == END){

	}

	PlayTone(500, 10);
	while(state.currentState == FAIL){
		stopMotors();
		state.currentState = END;
	}
}

void getSensors(State *state){

	//************************IR Sensor**************************

	int _dir = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;

	// read all of the sensors' values at once,
	// exit the app if an error occurs
	if (! HTIRSreadAllStrength(HTIRS, dcS1, dcS2, dcS3, dcS4, dcS5)) {
		nxtDisplayTextLine(4, "ERROR!!");
		wait1Msec(2000);
		StopAllTasks();
	}

	// read the direction from which the signal is coming,
	// exit the app if an error occurs
	_dir = HTIRSreadDir(HTIRS);
	if (_dir < 0) {
		nxtDisplayTextLine(4, "ERROR!!");
		wait1Msec(2000);
		StopAllTasks();
	}

	// display the info from the sensor
	/*nxtDisplayTextLine(0,"HT IR Seeker");
	nxtDisplayTextLine(2, "dir: %2d", _dir);
	nxtDisplayTextLine(3, "S1: %3d", dcS1);
	nxtDisplayTextLine(4, "S2: %3d", dcS2);
	nxtDisplayTextLine(5, "S3: %3d", dcS3);
	nxtDisplayTextLine(6, "S4: %3d", dcS4);
	nxtDisplayTextLine(7, "S5: %3d", dcS5);*/

	state->irDir = _dir;

	//*********************************************************

	//***********************Sonar*****************************

	state->dist = SensorValue[sonar];

	//*********************************************************

	//*****************Gyro and Accelerometer******************

	float rotSpeed = 0;
	float x_axis, y_axis, z_axis = 0;

	// Wait until 20ms has passed
	//wait1Msec(20);
	state->lastSensorCheckTime += 20;
	int waitTime = state->lastSensorCheckTime-time1[T2];
	if (waitTime >= 0 && waitTime <= 20) {
		wait1Msec(waitTime);
	} else {
		PlayTone(700, 1000);
		eraseDisplay();
			string errorDisplay;
			sprintf(errorDisplay, "missed %d",(int)(time1[T2] - state->lastSensorCheckTime));
			nxtDisplayTextLine(3, errorDisplay);
			stopMotors();
			wait1Msec(100000000000);
		state->lastSensorCheckTime = time1[T2];
	}


	// Read the current rotation speed
	rotSpeed = HTGYROreadRot(HTGYRO);
	HTACreadAllAxes(HTACCEL, x_axis, y_axis, z_axis);

	// Crude integration: waited 20ms so distance moved/degrees turned would be speed * time
	state->degrees += rotSpeed * 0.02;
	state->x_distance = x_axis * 0.02;
	state->y_distance = y_axis * 0.02;
	state->z_distance = z_axis * 0.02;

	//*********************************************************

	//*****************Show Debugging Window*******************

	showDiagnostics(state);

	//*********************************************************
}

void resetGyroAccel(State *state){
	state->degrees = 0;
	state->x_distance = 0;
	state->y_distance = 0;
	state->z_distance = 0;
}

void drive(State *state){
	motor[leftTread] = state->leftSpeed;
	motor[rightTread] = state->rightSpeed;
}

void stopMotors(){
	motor[leftTread] = 0;
	motor[rightTread] = 0;
}

void showDiagnostics(State *state){
	//create label
	string displayState = "state = ";
	string sonarSensor = "sonar = ";
	string irSensor = "IR = ";
	string gyroSensor = "Gyro =";
	string timer = "Timer = ";
	string batteryLevel = "power = ";

	//store variable in a string
	string string0 = state->currentState;
	string string1 = state->dist; //ServoValue[vert1];
	string string2 = state->irDir; //ServoValue[vert2];
	string string3 = state->degrees;
	string string4 = time1[T1];
	string string5 = externalBatteryAvg;

	//concat variable with label
	strcat(displayState, string0);
	strcat(sonarSensor, string1);
	strcat(irSensor, string2);
	strcat(gyroSensor, string3);
	strcat(timer, string4);
	strcat(batteryLevel, string5);

	eraseDisplay();

	//display label and value
	nxtDisplayTextLine(1, displayState);
	nxtDisplayTextLine(2, sonarSensor);
	nxtDisplayTextLine(3, irSensor);
	nxtDisplayTextLine(4, gyroSensor);
	nxtDisplayTextLine(5, timer);
	nxtDisplayTextLine(6, batteryLevel);
}
